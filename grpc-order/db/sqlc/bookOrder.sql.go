// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: bookOrder.sql

package db

import (
	"context"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO book_order (
  user_name,
  book_name,
  amount,
  address,
  total_price
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING order_id, user_name, book_name, amount, address, total_price, created_at
`

type CreateOrderParams struct {
	UserName   string  `json:"user_name"`
	BookName   string  `json:"book_name"`
	Amount     int32   `json:"amount"`
	Address    string  `json:"address"`
	TotalPrice float64 `json:"total_price"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (BookOrder, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder,
		arg.UserName,
		arg.BookName,
		arg.Amount,
		arg.Address,
		arg.TotalPrice,
	)
	var i BookOrder
	err := row.Scan(
		&i.OrderID,
		&i.UserName,
		&i.BookName,
		&i.Amount,
		&i.Address,
		&i.TotalPrice,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM book_order
WHERE order_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID int64) error {
	_, err := q.exec(ctx, q.deleteOrderStmt, deleteOrder, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, user_name, book_name, amount, address, total_price, created_at FROM book_order
WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, orderID int64) (BookOrder, error) {
	row := q.queryRow(ctx, q.getOrderStmt, getOrder, orderID)
	var i BookOrder
	err := row.Scan(
		&i.OrderID,
		&i.UserName,
		&i.BookName,
		&i.Amount,
		&i.Address,
		&i.TotalPrice,
		&i.CreatedAt,
	)
	return i, err
}

const listOrder = `-- name: ListOrder :many
SELECT order_id, user_name, book_name, amount, address, total_price, created_at FROM book_order
WHERE user_name = $1
ORDER BY created_at
LIMIT $2
`

type ListOrderParams struct {
	UserName string `json:"user_name"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) ListOrder(ctx context.Context, arg ListOrderParams) ([]BookOrder, error) {
	rows, err := q.query(ctx, q.listOrderStmt, listOrder, arg.UserName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookOrder
	for rows.Next() {
		var i BookOrder
		if err := rows.Scan(
			&i.OrderID,
			&i.UserName,
			&i.BookName,
			&i.Amount,
			&i.Address,
			&i.TotalPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE book_order
set 
  user_name = $2,
  book_name = $3,
  amount = $4,
  address = $5,
  total_price = $6
WHERE order_id = $1
RETURNING order_id, user_name, book_name, amount, address, total_price, created_at
`

type UpdateOrderParams struct {
	OrderID    int64   `json:"order_id"`
	UserName   string  `json:"user_name"`
	BookName   string  `json:"book_name"`
	Amount     int32   `json:"amount"`
	Address    string  `json:"address"`
	TotalPrice float64 `json:"total_price"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (BookOrder, error) {
	row := q.queryRow(ctx, q.updateOrderStmt, updateOrder,
		arg.OrderID,
		arg.UserName,
		arg.BookName,
		arg.Amount,
		arg.Address,
		arg.TotalPrice,
	)
	var i BookOrder
	err := row.Scan(
		&i.OrderID,
		&i.UserName,
		&i.BookName,
		&i.Amount,
		&i.Address,
		&i.TotalPrice,
		&i.CreatedAt,
	)
	return i, err
}
